/*
 */
#include <memory>
#include <cstring>
#include <vector>

extern "C" {
    #include "makestring.h"
}

#include <ESP8266WiFi.h>  // https://github.com/esp8266/Arduino
#include <ESP8266mDNS.h>
#include <WiFiManager.h> // https://github.com/tzapu/WiFiManager
#include <ArduinoJson.h>          //https://github.com/bblanchon/ArduinoJson

#include <propertyutils.h>
#include <optparser.h>
#include <utils.h>
#include <icons.h>
#include <crceeprom.h>
#include <pwmventilator.h>
#include <onoffventilator.h>

// #include <spi.h> // Include for harware SPI
#include <Adafruit_MAX31855.h>
#include <max31855sensor.h>
#include <max31865sensor.h>
#include <PubSubClient.h> // https://github.com/knolleary/pubsubclient/releases/tag/v2.6

#include "ssd1306displaycontroller.h"
#include <ESP_EEPROM.h>
#include <config.h>
#include <analogin.h>
#include <digitalknob.h>
#include <Fuzzy.h>

//#include "settingsdto.h"

#include <bbqfanonly.h>
#include <bbq.h>
#include <demo.h>
#include <statemachine.h>

#define CONTROLLER_CONFIG_FILENAME       "/controller.json"
#define BBQ_CONFIG_FILENAME              "/bbq.json"

// of transitions
volatile uint32_t counter50TimesSec = 1;

// Number calls per second we will be handling
#define FRAMES_PER_SECOND        50
#define EFFECT_PERIOD_CALLBACK   (1000 / FRAMES_PER_SECOND)

// Keep track when the last time we ran the effect state changes
volatile uint32_t effectPeriodStartMillis = 0;

// bbqCOntroller, sensors and ventilators
std::unique_ptr<BBQFanOnly> bbqController(nullptr);
std::shared_ptr<TemperatureSensor> temperatureSensor1(nullptr);
std::shared_ptr<TemperatureSensor> temperatureSensor2(nullptr);
std::shared_ptr<Ventilator> ventilator1(nullptr);

// START: For demo/test mode
MockedTemperature* mockedTemp1 = new MockedTemperature(20.0);
MockedTemperature* mockedTemp2 = new MockedTemperature(30.0);
// END: For demo/test mode

// WiFI Manager
WiFiManager wm;

std::shared_ptr<AnalogIn> analogIn = std::make_shared<AnalogIn>(0.2f);
DigitalKnob digitalKnob(BUTTON_PIN, true, 110);

// Stores information about the BBQ controller (PID values, fuzzy loggic values etc, mqtt)
StaticJsonDocument<1024> controllerConfig;
bool controllerConfigModified = false;
// Stores information about the current temperature settings
StaticJsonDocument<1024> bbqConfig;
bool bbqConfigModified = false;

// CRC value of last update to MQTT
uint16_t lastMeasurementCRC = 0;

// Eeprom storage
// wait 500ms after last commit, then commit no more often than every 30s
Settings eepromSaveHandler(
    500,
    10000,
[]() {
    saveConfigSPIFFS();
},
[]() {
    return bbqConfigModified || controllerConfigModified;
}
);

// MQTT Storage
// mqtt updates as quickly as possible with a maximum frequence of MQTT_STATE_UPDATE_DELAY
void publishToMQTT(const char* topic, const char* payload);
Settings mqttSaveHandler(
    1,
    MQTT_STATE_UPDATE_DELAY,
[]() {

},
[]() {
    return configurationModified;
}
);

// State machine states and configurations
std::unique_ptr<StateMachine> bootSequence(nullptr);



PubSubClient mqttClient(wm.server->client().);


///////////////////////////////////////////////////////////////////////////
//  Webserver
///////////////////////////////////////////////////////////////////////////

void serverOnlineCallback() {
/*     wm.server->on(JBONE_URI, []() {
        wm.server->sendHeader("Content-Encoding", "gzip");
        wm.server->setContentLength(jscript_js_gz_len);
        wm.server->send(200, "application/javascript", "");
        wm.server->sendContent_P((char*)jscript_js_gz, jscript_js_gz_len);
    });

    wm.server->on(TRACK_PEEK_URI, []() {
        char payloadBuffer[128];
        sprintf(payloadBuffer, "{\"yaw\":%.2f,\"pitch\":%.2f,\"roll\":%.2f,\"x\":%.2f,\"y\":%.2f,\"z\":%.2f}",
                last_measurement.yaw * 180 / M_PI,
                last_measurement.pitch * 180 / M_PI,
                last_measurement.roll * 180 / M_PI,
                last_measurement.x,
                last_measurement.y,
                last_measurement.z
               );

        wm.server->setContentLength(strlen(payloadBuffer));
        wm.server->send(200, F("application/javascript"), payloadBuffer);
    });

    wm.server->on(STORE_CALIBRATION_URI, []() {
        if (hwTrack->isReady()) {

            if (!json.containsKey(hwTrack->name())) {
                json.createNestedObject(hwTrack->name());
            }
            JsonObject config = json[hwTrack->name()].as<JsonObject>();
            hwTrack->calibrate(config);
            serializeJsonPretty(config, Serial);

            shouldSaveConfig = true;

            // Send result back
            wm.server->setContentLength(measureJson(config));
            wm.server->send(200, F("application/javascript"), "");
            WiFiClient client = wm.server->client();
            serializeJson(config, client);

            // Request restart
            shouldRestart = millis();
        } else {
            // We would like to send a 503 but tje JS framework doesn´t give us the body
            wm.server->send(200, F("application/json"), F("{\"status\":\"error\", \"message\":\"MPU is not ready, please check hardware.\"}"));
        }
    }); */

}

///////////////////////////////////////////////////////////////////////////
//  Utilities
///////////////////////////////////////////////////////////////////////////


/**
 * Send a command to the cmdHandler
 */
void handleCmd(const char* topic, const char* p_payload) {
    long m_mqttSubscriberTopicStrLength = properties.get("mqttSubscriberTopicStrLength").getLong();
    auto topicPos = topic + m_mqttSubscriberTopicStrLength;
    Serial.println(topic);
    Serial.println(p_payload);


    // Look for a temperature setPoint topic
    if (strstr(topicPos, MQTT_CONFIG_TOPIC) != nullptr) {
        BBQFanOnlyConfig config = bbqController->config();
        float temperature = 0;
        OptParser::get(p_payload, [&config, &temperature](OptValue values) {

            // Copy setpoint value
            if (strcmp(values.key(), "sp") == 0) {
                temperature = values.asFloat();
            }

            // Fan On/Off controller duty cycle
            if (strcmp(values.key(), "ood") == 0) {
                settingsDTO->data()->on_off_fan_duty_cycle = between(values.asLong(), (int32_t)5000, (int32_t)120000);
                ventilator1.reset(new OnOffVentilator(FAN1_PIN, settingsDTO->data()->on_off_fan_duty_cycle));
            }

            // Lid open fan speed
            if (strcmp(values.key(), "lof") == 0) {
                config.fan_speed_lid_open = between((int8_t)values.asInt(), (int8_t) -1, (int8_t)100);
            }

            // Copy minimum fan1 PWM speed in %
            if (strcmp(values.key(), "fs1") == 0) {
                settingsDTO->data()->fan_startPwm1 = values.asInt();
                // Tech Debth? Can we get away with static_pointer_cast without Ventilator knowing about any setPwmStart?
                std::static_pointer_cast<PWMVentilator>(ventilator1)->setPwmStart(values.asInt());
            }

            // Fan 1 override ( we don´t want this as an settings so if we loose MQTT connection we can always unplug)
            if (strcmp(values.key(), "f1o") == 0) {
                ventilator1->speedOverride(between(values.asFloat(), -1.0f, 100.0f));
            }

            config.fan_low = getConfigArray("fl1", values.key(), values.asChar(), config.fan_low);
            config.fan_medium = getConfigArray("fm1", values.key(), values.asChar(), config.fan_medium);
            config.fan_high = getConfigArray("fh1", values.key(), values.asChar(), config.fan_high);

            config.temp_error_low = getConfigArray("tel", values.key(), values.asChar(), config.temp_error_low);
            config.temp_error_medium = getConfigArray("tem", values.key(), values.asChar(), config.temp_error_medium);
            config.temp_error_hight = getConfigArray("teh", values.key(), values.asChar(), config.temp_error_hight);

            config.temp_change_fast = getConfigArray("tcf", values.key(), values.asChar(), config.temp_change_fast);
        });

        if (temperature > 1.0f) {
            settingsDTO->data()->setPoint = between(temperature, 90.0f, 240.0f);
            bbqController->setPoint(settingsDTO->data()->setPoint);
        }

        // Copy to settings
        settingsDTO->data()->lid_open_fan_speed = config.fan_speed_lid_open;
        settingsDTO->data()->fan_low = config.fan_low;
        settingsDTO->data()->fan_medium = config.fan_medium;
        settingsDTO->data()->fan_high = config.fan_high;
        settingsDTO->data()->temp_error_low = config.temp_error_low;
        settingsDTO->data()->temp_error_medium = config.temp_error_medium;
        settingsDTO->data()->temp_error_hight = config.temp_error_hight;
        settingsDTO->data()->temp_change_fast = config.temp_change_fast;

        // Update the bbqController with new values
        bbqController->config(config);
        bbqController->init();
    }

    if (strstr(topicPos, "reset") != nullptr) {
        OptParser::get(p_payload, [](OptValue v) {
            if (strcmp(v.key(), "1") == 0) {
                // TODO
            }
        });
    }

    // Dummy data topic during testing
    // With ot we can simulate a oven temperature
    // BBQ/xxxxxx/dummy
#ifdef DEMO_MODE

    if (strstr(topicPos, TEMPERATURE_DUMMY_TOPIC) != nullptr) {
        OptParser::get(p_payload, [](OptValue v) {
            if (strcmp(v.key(), "t1") == 0) {
                mockedTemp1->set(v.asFloat());
            }

            if (strcmp(v.key(), "t2") == 0) {
                mockedTemp2->set(v.asFloat());
            }
        });
    }

#endif
}

/*
* Publish current status
* to = temperature oven
* sp = set Point
* f1 = Speed of fan 1
* lo = Lid open alert
* lc = Low charcoal alert
*/
void publishStatus() {
    const char* format = "to=%.2f t2=%.2f sp=%.2f f1=%.2f lo=%i lc=%i f1o=%.1f";
    char buffer[(4 + 6) * 6 + 16]; // 10 characters per item times extra items to be sure
    sprintf(buffer, format,
            temperatureSensor1->get(),
            temperatureSensor2->get(),
            bbqController->setPoint(),
            ventilator1->speed(),
            bbqController->lidOpen(),
            bbqController->lowCharcoal(),
            ventilator1->speedOverride()
           );

    // Quick hack to only update when data actually changed
    uint16_t thisCrc = CRCEEProm::crc16((uint8_t*)buffer, strlen(buffer));

    if (thisCrc != lastMeasurementCRC) {
        publishToMQTT(properties.get("mqttStatusTopic").getCharPtr(), buffer);
    }

    lastMeasurementCRC = thisCrc;
}

///////////////////////////////////////////////////////////////////////////
//  Spiffs
///////////////////////////////////////////////////////////////////////////

bool loadConfigSpiffs(const char * filename, 
    StaticJsonDocument<1024> &json) {
    if (SPIFFS.begin()) {
        Serial.println("mounted file system");

        if (SPIFFS.exists(filename)) {
            //file exists, reading and loading
            Serial.println("reading config file");
            File configFile = SPIFFS.open(filename, "r");

            if (configFile) {
                Serial.println("opened config file ");
                StaticJsonDocument<1024> jsonTmp;
                DeserializationError error = deserializeJson(jsonTmp, configFile);

                if (error) {
                    Serial.print(F("Failed to read file: "));
                    Serial.println(filename);
                } else {
                    json = jsonTmp;
                    serializeJsonPretty(json, Serial);
                    return true;
                }
            }
        }
    }

    return false;
}


/**
 * Store custom oarameter configuration in SPIFFS
 */
bool saveConfigSPIFFS() {
    if (SPIFFS.begin()) {
        Serial.println("saving config");

        if (SPIFFS.begin()) {
            File configFile = SPIFFS.open(TRACKER_CONFIG_FILENAME, "w");

            if (!configFile) {
                Serial.println("failed to open config file for writing");
            } else {
                serializeJson(json, configFile);
                // serializeJsonPretty(json, Serial);
                configFile.close();
                return true;
            }
        }
    }

    return false;
}
///////////////////////////////////////////////////////////////////////////
//  WiFi
///////////////////////////////////////////////////////////////////////////

void setupWifiManager() {
    // set country
    wm.setCountry("US"); // setting wifi country seems to improve OSX soft ap connectivity, may help others as well
    wm.setWebServerCallback(serverOnlineCallback);
    wm.setConfigPortalTimeout(120);

    if (!wm.autoConnect("WM_AutoConnectAP")) {
        Serial.println("failed to connect and hit timeout");
        wm.startConfigPortal();
    }
    //if you get here you have connected to the WiFi
    wm.startWebPortal();
}

/*
void loadConfiguration(Properties& props) {
    // 00FF1234
    const char* chipId = makeCString("%08X", ESP.getChipId());
    // BBQ00FF1234
    props.put("mqttClientID", PV(makeCString(HOSTNAME_TEMPLATE, chipId)));
    // BBQ/00FF1234
    const char* mqttTopicPrefix = makeCString(MQTT_TOPIC_PREFIX_TEMPLATE, MQTT_PREFIX, chipId);
    props.put("mqttTopicPrefix", PV(mqttTopicPrefix));
    // BBQ/00FF1234/lastwill
    props.put("mqttLastWillTopic", PV(makeCString(MQTT_LASTWILL_TOPIC_TEMPLATE, mqttTopicPrefix)));
    // BBQ/00FF1234/config/state
    props.put("mqttConfigStateTopic", PV(makeCString(MQTT_CONFIG_TOPIC_STATE_TEMPLATE, mqttTopicPrefix)));
    // BBQ/00FF1234/status
    props.put("mqttStatusTopic", PV(makeCString(MQTT_STATUS_TOPIC_TEMPLATE, mqttTopicPrefix)));
    //  BBQ/00FF1234/+
    const char* mqttSubscriberTopic = makeCString(MQTT_SUBSCRIBER_TOPIC_TEMPLATE, mqttTopicPrefix);
    props.put("mqttSubscriberTopic", PV(mqttSubscriberTopic));
    // Calculate length of the subcriber topic
    props.put("mqttSubscriberTopicStrLength", PV((int32_t)std::strlen(mqttSubscriberTopic) - 2));
    // friendlyName : BBQ Controller 00FF1234
    props.put("friendlyName", PV(makeCString("BBQ Controller %s", chipId)));
    // Wigi username and password
    props.put("wifi_ssid", PV(WIFI_SSID));
    props.put("wifi_password", PV(WIFI_PASSWORD));
    // mqtt server and port
    props.put("mqtt_server", PV(MQTT_SERVER));
    props.put("mqtt_port", PV(MQTT_PORT));
    delete chipId;
}
*/



void setupMQTT() {
        // Setup mqtt
    if (controllerConfig.containsKey("mqttServer")) {
        mqttClient.setServer(
            controllerConfig["mqttServer"], 
            controllerConfig["mqttPort"].as<int>());
        mqttClient.setCallback([](char* p_topic, byte * p_payload, uint16_t p_length) {
            char mqttReceiveBuffer[64];
            Serial.println("p_topic");

            if (p_length >= sizeof(mqttReceiveBuffer)) {
                return;
            }

            memcpy(mqttReceiveBuffer, p_payload, p_length);
            mqttReceiveBuffer[p_length] = 0;
            handleCmd(p_topic, mqttReceiveBuffer);
        });
    }
}

void setupSensors() {
     #ifdef DEMO_MODE
    temperatureSensor1.reset(mockedTemp1);
    temperatureSensor2.reset(mockedTemp2);
    ventilator1.reset(new MockedFan());
#else
    // Sensor 1 is generally used for the temperature of the bit
    auto sensor1 = new MAX31865sensor(SPI_MAX31865_CS_PIN, SPI_SDI_PIN, SPI_SDO_PIN, SPI_CLK_PIN, RNOMINAL_OVEN, RREF_OVEN);
    sensor1->begin(MAX31865_3WIRE);
    temperatureSensor1.reset(sensor1);

    // Sensor 2 is generally used to measure the temperature of the pit itself
    auto sensor2 = new Adafruit_MAX31855(SPI_CLK_PIN, SPI_MAX31855_CS_PIN, SPI_SDI_PIN);
    sensor2->begin();
    temperatureSensor2.reset(new MAX31855sensor(sensor2));

    #if PWM_FAN == 1
    ventilator1.reset(new PWMVentilator(FAN1_PIN, settingsDTO->data()->fan_startPwm1));
    #elif ON_OFF_FAN == 1
    ventilator1.reset(new OnOffVentilator(FAN1_PIN, settingsDTO->data()->on_off_fan_duty_cycle));
    #else
    #error Should pick PWM_FAN or ON_OFF_FAN
    #endif
#endif
}

void setupBBQController() {
 // Setup BBQ Controller
    bbqController.reset(new BBQFanOnly(temperatureSensor1, ventilator1));
    if (!controllerConfig.containsKey(bbqController->name())) {
        controllerConfig.createNestedObject(bbqController->name());
    }
    if (!controllerConfig.containsKey("setPoint")) {
        controllerConfig["setPoint"] = 20.f;
    }
    JsonObject nestedConfig = controllerConfig[bbqController->name()].as<JsonObject>();
    bbqController->setConfig(nestedConfig);
    bbqController->getConfig(nestedConfig);
    bbqController->setPoint(bbqConfig["setPoint"].as<float>());
}

///////////////////////////////////////////////////////////////////////////
//  SETUP() AND LOOP()
///////////////////////////////////////////////////////////////////////////

void setup() {
    //********** CHANGE PIN FUNCTION  TO GPIO **********
    //https://www.esp8266.com/wiki/doku.php?id=esp8266_gpio_pin_allocations
    //GPIO 1 (TX) swap the pin to a GPIO.
    pinMode(1, FUNCTION_3);
    //GPIO 3 (RX) swap the pin to a GPIO.
    pinMode(3, FUNCTION_3);
    //**************************************************

    // Enable serial port
    Serial.begin(115200);
    delay(50);

    setupWifiReconnectManager();
    setupWifiManager();

    // load configurations
    loadConfigSpiffs(CONTROLLER_CONFIG_FILENAME, controllerConfig);
    loadConfigSpiffs(BBQ_CONFIG_FILENAME, bbqConfig);

    setupSensors();
   
    setupBBQController();
    setupMQTT();

    /////////////////////////////////////////////////////////////////
    bbqController->init();

    Serial.println(F("End Setup"));
    effectPeriodStartMillis = millis();
}

#define NUMBER_OF_SLOTS 10
void loop() {
    const uint32_t currentMillis = millis();
    int remainingTimeBudget = ssd1306displayController.handle();

    if (remainingTimeBudget > 0 && currentMillis - effectPeriodStartMillis >= EFFECT_PERIOD_CALLBACK) {
        effectPeriodStartMillis += EFFECT_PERIOD_CALLBACK;
        counter50TimesSec++;

        // DigitalKnob (the button) must be handled at 50 times/sec to correct handle presses and double presses
        digitalKnob.handle();
        // Handle analog input
        analogIn -> handle();

        // Handle BBQ inputs once every 5 seconds
        if (counter50TimesSec % 50 == 0) {
            bbqController -> handle();
        }

        // once a second publish status to mqtt (if there are changes)
        if (counter50TimesSec % 50 == 0) {
            publishStatus();
        }

        ventilator1->handle();

        // Maintenance stuff
        uint8_t slot50 = 0;

        if (counter50TimesSec % NUMBER_OF_SLOTS == slot50++) {
            bootSequence->handle();
        } else if (counter50TimesSec % NUMBER_OF_SLOTS == slot50++) {
            mqttClient.loop();
        } else if (counter50TimesSec % NUMBER_OF_SLOTS == slot50++) {
            eepromSaveHandler.handle();
        } else if (counter50TimesSec % NUMBER_OF_SLOTS == slot50++) {
            mqttSaveHandler.handle();
        } else if (counter50TimesSec % NUMBER_OF_SLOTS == slot50++) {
            temperatureSensor1->handle();
        } else if (counter50TimesSec % NUMBER_OF_SLOTS == slot50++) {
            temperatureSensor2->handle();
        }


    }
}
